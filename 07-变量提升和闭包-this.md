变量提升和闭包

## 变量提升

> 当浏览器开辟出供代码执行的栈内存后，代码并没有自上而下立即执行，而是继续做了一些事情：**把当前作用域中所带有var / function 关键字的进行提前的声明和定义 => 变量的提升机制**
>
> - 带var的只是提前声明（declare）“ var a” 如果只有声明没有赋值，默认是undefined
> - 带function的不仅声明，而且还定义了（defined）

**var / 和不带var**

- 不带var  相当于创建全局变量  给Windon添加属性
- 带var  在全局下声明 也同样想当于给Windon增加了

## let / const 和 var 的区别

-  let 和 const 不存在变量提升的机制
  > 创建变量的6 种方法：var / function 有变量提升机制，而 let cosnt class import
- var 允许重复声明，而let是不允许的

  > 在相同作用域中（或执行上下文中）
  >
  > - 如果使用 var / function关键字声明变量并且重复声明，是不会有影响的
  > - 但是使用let const就不行，浏览器会校验当前作用域中是否已经存在这个变量了，如果存在了，则再次基于let 等重新声明就会报错

~~~JavaScript
// 在浏览器开辟栈内存供代码之上而下执行前，不仅有变量提升的操作，还有很多其他的操作=>“词法解析”or “词法检查”：就是检查当前即将要执行的代码是否会出现语法错误
console.log(1)
let a=12;
console.log(a) // SyntaxError 语法错误
let a=13;
console.log(a)
//代码会直接报错（一行都不会执行）
//Uncaught SyntaxError: Identifier 'a' has already been declared 
//语法错误

// 代码执行先开辟一个代码自上而下执行上下文，在词法解析，在变量提升，在代码执行（大概就是这个）

==================

// => 所谓重复：不管之前通过什么办法，只要当前栈内存中存在了这个变量，我们使用let / const 等重复声明的就会报错
console.log(a)
var a =12;
let a=13;  // SyntaxError 语法错误
console.log(a)

//进入一个执行环境上下文 先进行语法解析和变量提升 不管里面的代码如何
~~~

- let 能够解决typeof 检查时出现的暂时性死区的问题

```javascript
// console.log(a)
//  VM1071:1 Uncaught ReferenceError: a is not defined

//console.log(typeof a);
//=>"undefined" 这是浏览器的BUG 本来是应该报错，因为没有声明a（暂时性死区）

console.log(typeof a);
let a //Uncaught ReferenceError: b is not defined
```

- let  / const / class 等创建的变量会把大括号（除对象的大括号之外）当做一个全新的私有块级作用域

  - 函数执行会产生私有栈内存（作用域 执行上下文）
  - let等也会产生私有作用域（var不会）

  ~~~JavaScript
  let a =12 
  function fn(){
    //这个也会报错 就算let 没有变量提升但是 词法解析会找出私有栈内存有一个
    //let a 此时的私有栈内存中的a是私有的
    console.log(a)
    let a =13
  }
  fn()
  console.log(a)
  ~~~


<font color="red">函数执行形成的私有栈内存，会把内存中所有的私有变量保护起来，和外面没有任何的关系=>函数执行的这种**包含机制**叫**闭包**</font>

## 闭包

> 闭包的两个作用
>
> ·1. 保护（私有变量和外界没有必然联系）
>
> 2. 保存（形成不被销毁的栈内存，里面的私有变量等信息呗保留下来了）
>
>
> 市面上认为的闭包：函数执行形成不能被释放的私有栈内存，这样的才是闭包

### 闭包作用域

1. 创建函数
   - 开辟一个堆内存
   - 把函数中的代码当做字符串存储进去
   - 把堆内存的地址赋值给函数名 / 变量名
   - **函数在哪创建，那么它执行时候所需要查找的上级作用域是谁**

2. 函数执行

   - 形成一个全新的私有作用域，私有栈内存（执行一次形成一个，多个之间也不会产生影响）
   -  形参赋值 & 变量提升 (词法解析)
   - 代码执行（把所属堆内存中的代码字符串拿出来一行一行执行）
   - **遇到一个变量，首先看它是不是私有变量（形成和私有作用越中声明变量是私有变量），是私有的就操作自己的变量即可，不是私有的则向上级查找。。一直到全局作用越为止=》作用越查找机制**
   - 私有变量和外界变量没有必然的关系，可以理解为被私有栈内存保护起来，这种机制其实就是**闭包的保护机制**

3. 关于堆栈内存释放的问题（以谷歌内存为例）

> 函数执行就会形成栈内存（从内存中分配的一块空间），如果内存都不销毁释放，就能容易会导致栈内存溢出（内存爆满，电脑就卡死了）。

- 堆内存释放问题

  ~~~~javascript
  // 创建一个引用类型值，就会产生一个堆内存
  //如果当前创建的堆内存不被其它东西占用了（浏览器会在空闲的时候，查找内存的引用状况，不被占用的都会被回收释放）,则会被释放
  
  
  let obj = {
    name:'ccxs'
  };
  let oop =obj 
  // 此时obj和oop都占用着对象的堆内存，想要释放堆内存，需要手动解除变量和值的关联（bull：空指针对象）
  obj = nill
  oop = null
  ~~~~

- 栈内存释放

~~~javascript
// 打开浏览器形成的全局作用域是栈内存
// 手动执行函数形成的私有作用域是栈内存
// 基于ES6中的let / const 形成的块级作用域也是栈内存

/**
 * 全局内存：关闭页面的时候才会销毁
 * 私有栈内存：
 *    1. 一般情况下，函数执行完成，形成的私有栈内存就会被释放掉（排除无限递归，出现死循环的模式）
 *    2. 但是一旦栈内存中的某个东西（一般都是堆地址）被私有作用域以外的事情给占用了，则当前私有栈内存不能被立即释放销毁（特点：私有栈内存的私有变量信息也被保留下来了）=》 市面上认为的闭包：函数执行形成不能被释放的私有栈内存，这样的才是闭包
*/
function fn(){
  //....
}
fn() // 函数执行形成栈内存，执行完成栈内存销毁

function x(){
  return function(){
    //..
  }
}
let f= x() //f占用了x执行形成的栈内存中的某一个东西（返回小函数对应的堆），则x执行形成的栈内存不能被释放
~~~

## this

> 函数执行的主体（不是上下文）：意思是谁把函数执行的，那么执行主体就是谁

1. 给元素的某个事件绑定方法，当事件触发方法执行的时候，方法中的this是当前操作的元素本身
2. 当方法执行的时候，我们看方法前面是否有点，没有点就是window或者undefined；有点，点前面是this是谁就是谁

<font color="red">this的创建和它在什么地方创建和它在什么地方执行的没有什么关系</font>



```javascript
var a =1;
function fn(a){
  console.log(a) //输出的是一个函数
  var a =2;
  function a(){}
}
fn(a);

//document.parentNode 和 document.parentnode的区别
//document没有父节点 就是 null 
//document.parentnode 没有这个属性就是undefined
```

