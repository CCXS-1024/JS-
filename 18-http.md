## 客户端和服务器端

> 客户端：可以向服务器发送请求，并接收返回的内容进行处理
>
> 服务器端：能接收客户端请求，并且把相关资源信息返回给客户端

~~~html
面试题：用户输入URL的时候到最后看见了什么
1. url地址解析
2. DNS域名解析
3. 建立TCP链接
4. 把客户端信息传递给服务器（发送HTTP请求）
5. 服务器得到并处理请求（HTTP响应内容）
6. 客户端渲染服务器端渲染的内容
7. 和服务器断开TCP链接

服务器接受到请求后
1. 根据端口号找到对应的项目
2. 根据请求资源的路径名称找到资源文件
3. 读取资源文件中的内容
4. 把内容返回
~~~

### URL/URI/URN

> URL:统一资源定位符，根据地址能找到对应的支援
>
> URN：统一资源名称
>
> URI：统一资源标识符，URL和URN是URI的子集

### 一个完整URL

- 协议(http://)  ：能够把客户端和服务器端通信的信息，进行传输的工具
  - http  超文本传输协议，除了传递文本，还可传递媒体资源文件（或者流文件）
  - https ： 更加安全的http（加密传输）
  - ftp：文件传输协议（一般用于把本地支援上传到服务器端）
- 域名（www.baddu.com）：一个让用户方便记忆的名字（不通过域名，直接通过服务器的外网IP也能访问到服务器，但是外网IP很难被记住）
  - 顶级域名 qq.com
  - 一级域名 www.qq.com
  - 二级域名 sports.qq.com
  - 三级域名 kbs.sports.qq.com
  - .com 国际域名
  - .cn 中文域名
- 端口(:80) ：取值范围0~65535，用端口来区分同一台服务器上不同项目
  - http默认端口号433
  - https 433
  - ftp 21
  - 默认端口号可以不用写浏览器在发送请求的时候会帮我们加上
- 请求支援路径名称（/sty/index.html）
  - 默认的路径或者名称有可能是default.html、index.html
  - 注意为URL处理
- 问号传参（?from=wx）
  - 客户想把星系传递给服务器
    - url地址传参
    - 请求报文传输
  - 也可以不同页面之间的信息交互

- HASH值（#ccxs ）
  - 能进行信息的传输
  - 锚点定位
  - 基于HASH实现路由管理（不同的HASH值，展示不同的模块）

~~~JavaScript
window.location.href //可以获取当前的地址
window.location.href='http://www....'//可以进行页面的跳转
window.open('http://www...')//在新的页面进行页面的跳转

// 请求中出现非有效UNICODE编码的内容，现代版浏览器会默认进行编码
//1.基于encodeURI编码 我们可以基于decodeURI解码默认情况下是对整个URL进行编码
//2.可以用encodeURIComponent()对部分进行编码 decondeURIComponent 解码
//3. 客户端还基于一种方式，针对于中文的解码方式eacape/unescape,这种方式一般只用于客户端页面之间自己的处理，例如：从页面跳转到详情，我们可以把传递的中文信息基于这个编码，详情获取编码后的信息在解码，比如客户端中的cookie信息，如果信息是中文，我们也基于这种方法编码
~~~

### DNS域名解析

- DNS服务器：域名解析服务器，在服务器上存储着域名<=>外网IP相关的记录
- 所谓的域名解析就是在DNS服务器上找到对应外网IP

**DNS优化**

- DNS缓存（一般浏览器堆在第一次 解析后，默认会建立缓存，时间很短，只有一分钟左右）
- 减少DNS解析的次数
- DNS预获取（dns-prefetch）:在页面加载开始的时候，就把当前页面中需要访问其它域名（服务器）的信息提前DNS解析，以后在加载到具体内容部分就不用解析了

### 建立TCP链接（三次握手）

> 客户端向服务器端发送一个SYN=1和seq=j的标识符 服务器会把SYN=1返回还会多返回一个ACK =1 ack=j+1，和seq=k

![截屏2022-08-20 14.15.00](/Users/ccxs/Documents/笔记/js-笔记/18-http.assets/截屏2022-08-20 14.15.00.png)

### 发送HTTP请求

1. HTTP请求报文
   - 起始行
   - 请求头
   - 请求主体

<hr/>

1. 强缓存和协商缓存

**HTTP报文**

- 请求报文：所有经过传输协议，客户端传递给服务器的内容，都被称为请求报文
  - 请求头
  - 请求行
  - 请求主体
- 响应报文：所有经过传输协议，服务器返回给客户端的内容，都被称为响应报文
  - HTTP状态码
  - 响应头
  - 响应主体
- HTTP报文：请求报文+响应报文

### HTTP响应内容

- http状态码
  - 200 ok： 成功
  - 201 CREATED：一般用于告诉服务器创建一个新文件，最后服务器创建成功后的状态码
  - 204 NO CONTENT：对于某些请求，服务器不想处理，可以返回空内容，并且用204状态码告知 
  -  301 MOVED PERMANENTLy：永久重定向（永久转移）
  - 302 MOVED Temporarily：临时转移，很早以前用302来做，但现在主要用307来处理这个事件，307的意思就是设置临时重定向=》主要用于服务器的负载均衡
  - 304 NOT Modified :设置HTTP的协商缓存
  - 400 BAd request：传递给服务器的参数错误
  - 401 UNauthorized：无权限访问
  - 404： NOT Found：请求地址错误
  - 500： 未知服务器错误
  - 503：服务器超负荷

### 客户端渲染服务器端渲染的内容

>  在渲染HTML的时候遇到link/img/audio/video等是异步去加载资源信息（浏览器分配一个新的线程，主线程继续向下渲染页面），如果遇到script或者@import，则让主线程去加载信息（同步），加载完成信息后，再去渲染页面

![截屏2022-08-20 17.21.33](/Users/ccxs/Documents/笔记/js-笔记/18-http.assets/截屏2022-08-20 17.21.33.png)

#### 浏览器渲染页面的步骤

- 解析HTML生成DOM树，解析CSS生成CSSOM树
- 将DOM树和CSSOM树合并，生成渲染树
- layout（回流）：根据生成的渲染树，计算设备视口内的确切位置和大小，这个阶段是回流
- painting（重绘）：根据渲染树以及回流得到的信息，得到节点的绝对元素
- Dispkay：将像素发送给GPU，展示在页面上

####  2.DOM的重绘和回流

- 重绘：元素的改变（但是宽高大小，位置不变）

  - 如outline，visibility，color，background-color等

- 回流：元素的大小或者位置发生了变化（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算或者渲染

  - 如添加或删除可见的DOM元素;元素的位置发生变化;元素的尺寸发生变化;内容发生变化（比如文本
    交化或图片被另一个不同尺寸的图片所替代）：页面一开始渲染的时候（这个无法避免）；因为回流是根据视的大小来计算元素的位置和大小的，所以浏览器的窗口尺寸变化也会引发回流。

<font color="red">注意：回流一定会触发重绘，而重绘不一定回流</font>

**前端优化：避免DOM回流**

1. 放弃传统操作dom的时代，基于vue和/react开始数据渲染视图
2. 分离读写操作（现代浏览器都有渲染队列的机制）
   - offsetTop., offsetLeft, offsetWidth, offsetHeight, clientTop, clientLeft, clientWidth, clientHeight
     scrollTop、scrollLeft. scrollWidth. scrollHeight. getcomputedstyle、currentstyle...会刷新渲染队列
3. 样式集中改变
   - Div.style.ccsText='width:20px;height:20px'
   - Div.className='box'
4. 动画效果应该用定位（让它脱离文档流
5. 避免table布局和使用css的js表达式
6. CSS3硬件加速（GPU加速）
   - 比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘;transform 1 opacity \ filters 这些属性会触发硬件加速，不会引发回流和重绘。
7. 牺牲平滑度换取速度
   - 每次1像素移动一个动画 ，但是如果此动画使用了100%的CPU，动画就会看上去是跳动的，因为浏览
     器正在与更新回流做斗争。每次移动了像素可能看起来平滑度低了，但它不会导致CPU在较慢的机器中抖动

### 和服务器端断开链接（TCP的4次挥手）

**Connection:keep-Alive保持TCP不中断**
